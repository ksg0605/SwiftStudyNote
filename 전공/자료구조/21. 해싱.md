
## 14.1 해싱이란?
> 키에 산술적인 연ㅅ나을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근
> 키에 대한 연산에 의해 직접 접근이 가능한 구조를 해시 테이블이라고 하고, 해시 테이블을 이용한 탐색을 해싱

## 14.2  추상 자료형 사전
사전은 키와 값의 쌍
- 키: 사전의 단어처럼 항목과 항목을 구별시켜주는 것
- 값: 단어의 설명에 해당
리스트는 근본적으로 위치에 의하여 관리되는 자료, 사전은 오직 키에 의해서만 관리
## 14.3 해싱의 구조
> 해싱에서는 자료를 저장하는데 배열을 사용
> 만양 원하는 항목이 들어 있는 위치를 알고 있다면 매우 빠르게 자료를 삽입하거나 꺼낼 수 있음
> 이 경우 배열의 다른 요소에는 접근할 필요없음
> 그래서 해싱은 항목의 키만을 가지고 바로 항목이 들어 있는 배열의 인덱스를 결정하는 기법
> 해시 함수란 키를 입력받아 해시주소를 생성하고 이 해시주소를 해시 테이블의 인덱스로 사용

![](https://blog.kakaocdn.net/dn/dsWloM/btrGhzPmbSg/FHtEdeExsuHTfDGK0IK3Zk/img.png)
- 같은 키인 경우 충돌 각각의 키를 동의어라고 함
- 충돌이 밠생하면 같은 버킷ㅇ데 있는 다른 슬롯에 항목 저장
- 충돌이 자주 발생하면 버킷 내부의 순차 탐색 시간이 길어져서 탐색 성능이 저하
- 해시함수를 수정하거나 해시테이블의 크기를 조절해야 함
- 버킷에 할당된 슬롯 수보다 충돌이 많이 발생하면 오버플러오
- 버킷 당 슬롯의 수가 하나이면 충돌이 곧 오버플로우를 의미
## 14.4 해시함수
- 충돌이 적어야 한다
- 해시함수 값이 해시테이블의 주소 영역 내에서 고르게 분포되어야 한다
- 계산이 빨라야 한다
### 제산 함수
나머지 연산자를 사용하여 키를 해시 테이블의 크기로 나눈 나머지를 해시 주소로 사용하는 방법
가장 일반적인 해시 함수로서 해시 테이블의 크기 M은 주로 소수로 선택
해시 주소를 고르게 분포시키는 좋은 방법
테이블의 크기인 M은 항상 홀수여야 함, 만약 M이 소수라면 즉, 자기 자신과 1만을 약수로 가지는 수라면 k mode m은 0에서 m-1을 골고루 사용하는 값을 만들어낸다
만약 나머지 연산을 수행했을 때 음수가 나올 가능성에도 대비해야 함, 따라서 k mod 이 음수라면 여기에 M을 더해서 결과값이 항상 0에서 m-1이 되도록 해야 함
### 폴딩 함수
- 키가 해시 테이블의 크기보다 더 큰 정수일 때 사용
- 키의 일부만 사용하는 것이 아니고
- 키를 몇 개의 부분으로 나누어 이를 더하거나 비트별로 부울 연산을 사용
- 키를 여러 부분으로 나누어 모두 더한 값을 해시 주소로 사용
- 이동 폴딩: 키를 여러 부분으로 나눈 값들을 더하여 해시 주소로 사용
- 경계 폴딩: 키의 이웃한 부분을 거꾸로 더하여 해시 주소를 얻음
### 중간 제곱 함수
- 키를 제곱한 다음, 중간의 몇 비트를 취해서 해시 주소를 생성
- 키 값을 제곱한 값의 중간 비트들의 값은 비교적 고르게 분산
### 비트 추출 방법
- 해시 테이블의 크기가 M = 2^k일 때 키를 이진수로 간주하여 임의의 위치의 k개의 비트를 해시 주소로 사용하는 것, 해시 주소의 집중 현상이 일어날 가능성이 높다
### 숫자 분석 방법
- 키에서 각각의 위치에 있는 수의 특징을 미리 알고 있을 때 유용
- 각각의 위치에 있는 숫자 중에서 편중되지 않는 수들을 해시 테이블의 크기에 적합한 만큼 조합하여 해시 주소로 사용하는 방법
### 탐색키가 문자열일 경우 주의할 점
- 가장 보편적인 방법은 문자의 아스키 코드값이나 유니코드값을 사용
- 첫 번째 문자의 아스키 코드값을 해시 주소로 사용
- 충돌을 막기 위해서는 문자열안의 모든 문자를 골고루 사용
- 각 문자의 아스키 값을 모두 더함
- 서로다른 키들이 같은 문자로 이루어져 있지 않는 한, 비교적 잘 동작
- 키들이 동일한 문자로 이루어져 있을 경우 구분 불가
- 아스키 코드 값에 위치에 기초한 값을 곱함
- 이 방법은 키가 긴 문자열로 이루어져 있으면 오버플로우가 발생할 수 있음
### 14.5 개방 주소법
오버플로우를 효과적으로 해결하는 방법이 필요
- 개방 주소법
- 체이닝
### 선형 조사법
- 특정 버킷에서 충돌이 발생하면, 비어있는 버킷을 찾는 방법
- 해시테이블에서 비어있는 공간을 찾는 것을 조사라고 함
- 간단하지만 키들이 집중되어 저장됨
- 최악의 경우엔 집중된 항목들이 결합됨 -> 탐색 시간 증가
- 오버플로우가 자주 발생하면 집중과 결합에 의해 탐색의 효율이 크게 저하될 수 있음
### 이차 조사법
- 선형 조사식과 유사하지만
- 다음조사할 위치를 다음 식에의해 결정
```
(h(k) + inc * inc) mod M for inc=0, 1, ..., M-1
```
- h(k), h(k)+1, h(k)+2, h(k)+3...
- 여전히 테이븦 크기는 소수여야 함
- 선형 조사법의 문제인 집중과 결합을 크게 완화 가능
### 이중 해싱법
- 오버플로우가  발생함에 따라 항목을 저장할 다음 위치를 결정할 때, 
- 원래 해시 함수와 다른 별개의 해시 함수를 이용하는 방법
## 14.6 체이닝
- 오버플로우 문제를 연결 리스트로 해결
- 키들의 중복을 허용한다면 연결 리스트의 처음에다 삽입하는 것이 가장 효율적
- 중복이 허용되지 않는다면 연결리스트를 처음부터 탐색하여야 하므로
- 어차피 연결 리스트의 뒤로 가야하고 여기에다 삽입하는것이 자연스러움
- 체이닝은 해시 테이블을 연결 리스트로 구성하므로 필요한 만큼의 메모리만 사용하게 되어
- 공간 활용 우수
- 오버플로우가 발생해도 해당 버킷에 할당된 연결리스트만 처리하게 되므로 수행시간도 효율적
