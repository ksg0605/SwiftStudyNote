- 질의문은 먼저 검사를 하고 파싱을 함
- 검사기는 질의문에 나온 언어의 요소(토큰)을 식별하고
- 파서는 질의문을 분석해서 구문법에 맞는지, 의미상으로 맞는지 검사
- 컴퓨터가 처리할 수 있는 트리나 그래프 자료구조의 내부 표현으로 변환 -> 질의문 트리, 질의문 그래프
- DBMS는 실제로 데이터가 저장되어 있는 데이터 파일에 접근하여 질의문 지시에 따라 데이터를 처리할 수 있도록 실행 계획을 세워야 함
- 질의문 실행, 데이터를 접근하고 중간 결과를 저장하는 데 필요한 계획으로 질의문 계획이라고 함
- 계획 중 가장 적절한 계획을 선택하는 과정을 질의어 최적화라고 함
![[스크린샷 2024-01-14 오후 9.06.19.png]]
- 질의어  최적기: 질의문 계획을 생성, 선정
- 코드 생성기: 이 계획을 실행시키기 위한 코드를 생성
- 런타임 데이터베이스 처리기: 코드를 실행시커 질의문 처리결과 생성
DBMS는 실렉트나 조인과 같은 저급 관계 연산자들을 구현한 여러가지 프로시저들을 가지고 있다
실행 전햑은 이런 프로시저들을 적절히 호출하는 방법으로 구현
## 질의어 최적화
1. 사용자 질의문을 어떤 형식의 내부표현으로 변환
2. 이 내부 표현을 논리적 변환 규칙을 이용해 의미적으로 동등한, 그러나  처리하기에 보다 효율적인 내부 표현으로 변환
3. 이 변환된 내부 표현을 구현시킬 후보 프로시저들을 선정하고, 프로시저들로 구성된 질의문 계획을 평가하여 가장 효율적인 것을 선정
### 1. 질의문의 내부 표현
- 사용자의 질의문을 컴퓨터가 처리하기에 적절한 내부 표현으로 변환
- 이것은 사용자가 질의문을 작성하기에 편리하도록 첨가시킨 부수적인 구문을 제거하는 작업도 포함
- 질의문 내부 표현 형태는 보통 트리구조 -> 질의문 트리
- 하나의 질의문 트리는 하나의 질의문을 나타낸다
- 질의문 트리에서 단말 노드는 피 연산자인 릴레이션이 되고 내부 노드들은 관계대수 연산자가 됨
![[스크린샷 2024-01-14 오후 9.28.16.png]]
### 2. 효율적 내부 형태로 변환
- 하나의 질의문을 표현하는 동등한 관계 대수식(질의문 트리)는 하나 이상이 있을 수 있다
- 앞서 파서가 생성한 내부 표현은 특별한 최적화 과정을 거치지 않은 일반 표준 트리
- 두번째 단계에서는 어떤 정립된 변환 규칙에 따라 처리면에서 효율적인 내부 형태로 변환하는 작업을 수행한다
```mysql
# 과목 C413에 등록한 학생의 이름을 검색하라

SELECT SNAME
FROM S, E
WHERE S.SNO = E.SNO AND CNO = 'C413';
```
- 만일 학생 릴레이션의 투플 수 가 100, 등록 릴레이션의 수가 10000, 과목 C413에 등록한 학생이 50명이라면
[방법1]
1. 학생 릴레이션과 등록 릴레이션을 조인하여 임시 릴레이션 R1을 만듬
	- 등록 투플 10000개를 읽고 다시 100개의 학생 투플을 10000번(각 등록 투플에 대해 한번씩) 디스크로부터 판독하여 조인한 뒤 10000개의 투플로 된 결과 릴레이션 R1을 디스크에 기록, 저장
2. R1에서 과목 번호가 C413인 투플을 선택하여 임시 릴레이션 R2를 만든다
	- 10000개의 투플을 판독하고 50개로 된 릴레이션 R2를 생성
3. 이 임시 릴레이션 R2를 학생이름으로 프로젝션하여 최대 50개의 투플로 된 최종 결과를 생성
[방법2]
1. 등록 릴레이션에서 과목번호가 C413인 투플들을 선택해 임시 릴레이션 R1을 만든다
   -> 10000개의 등록 투플들을 디스크에서 읽고 50개의 투플로 된 결과 R1을 생성한다
2. R1을 학생 릴레이션과 조인하여 임시 릴레이션 R2를 만든다 -> 학생 릴레이션의 100개 투플을 디스크로부터 판독하고 결과 R2에는 50개의 트플을 포함
3. 이 임시 릴레이션 R2에 학생이름으로 프로젝션하여 최대 50개의 투플로 된 결과를 생성

> 방법 1은 1030000 투플 입출력이 필요하고 방법 2는 10100 투플 입출력을 필요로 한다
> 따라서 방법 2가 방법 1보다 100배 낫다고 볼 수 있음
> 파서가 만들어낸 질의문의 내부 표현을 동등하면서도 처리에 효율적인 형태로 변환하기 위해서는 정립된 변환 규칙이 필요하다
> 조인을 먼저하고 실렉션을 하는 관계 대수식은 실렉션을 먼저하고 조인을 하는 대수식으로 변환
### 3. 후보 프로시저 선정
- 주어진 최종 내부 표현을 일련의 저급 연산, 즉 조인 프로시저, 실렉트 프로시저 등으로 명세하는 것
### 4. 질의문 계획 평가 및 결정
- 후보 질의문 계획을 평가하고 그 중에서 최상의, 즉, 최소 비용의 계획을 결정
- 각 질의문 계획은 최적화된 내부 표현에 있는 각 연산에 대해 하나의 시행 프로시저를 골라 이들을 모두 조합해 구성
- 주어진 질의문 하나에 대해 여러개의 후보 질의문 계획들이 만들어질 수 있음
- 너무 많은 계획을 생성하고 하나를 고르는것도 비용이 많이 들기 때문에 적당한 질의문 계획을 생성하고 평가하는 것이 바람직(자습적기법)
- 비용식에 고려하는 요소들
	- 디스크 입출력 비용 
	- 저장 비용
	- 계산 비용
	- 통신 비용
	- 일반적으로는 보조기억장치에 대한 접근 비용을 최소화하는 것에 주안점을 둔다
## 내부 형태 변환 규칙
> 한 질의문의 내부 형태, 즉 질의문 트리를 또 다른 질의문 트리로 변환 할 때의 기본 원칙은 이 질의문 트리들이 모두 동등해야 한다는 것이다
> 여기서 동등은 두 질의문 트리를 실행하면 항상 같은 결과를 제공한다는 의미
> 동등한 변환을 위해 동등성을 유지하는 변환 규칙을 이용해야 한다

![[스크린샷 2024-01-15 오전 10.30.38.png]]
![[스크린샷 2024-01-15 오전 10.30.51.png]]
1. 논리곱으로 된 조건을 가진 실렉트 연슨은 분해하여 개별적으로 변환
2. 다른 연산자를 포함하는 실렉트 연산은 선택 조건의 애트리뷰트가 허용하는 내에서 실렉트 연산이 먼저 실행되도록 변환
3. 제한적 실렉트 연산이 가장 먼저 실행 (선택 결과나 피 연산 릴레이션이 가장 작은 것을 의미)
4. 카디션 곱 연산 다음 실렉트 연산이 나오는 것은 하나의 조인으로 통합
5. 프로젝트 연산은 애트리뷰트를 분해해서 개별적 프로젝트로 만들어 프로젝트 연산이 먼저 실행되도록 함
6. OR로 연결된 조건식은 논리곱 정형식으로 변환
가능한 실렉트 연산을 먼저 실행시켜 투플 수를 줄이고 프로젝트를 일찍 수행하여 애트리뷰트를 줄이는 것

