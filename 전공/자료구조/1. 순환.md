## 1.1 순환의 소개
어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법
### 순환의 예
```C
int factorial(int n) {
	if(n <= 1) {
		return 1;
	} else {
		return (n * factorial(n - 1));
	}
}
```
- 아이디어는 제작하는 함수가 n을 매개변수로 받아서 n!을 구하는 함수라는 점
- 매개변수만 (n-1)로 변경해주면 (n-1)! 값을 계산
### 순환 호출의 내부적인 구현
- 프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일
- 복귀주소가 시스템 스택에 저장되고 호출되는 함술흘 위한 매개변수와 지역 변수를 스택으로부터 할당받는다
- 함수호출마다 새로운 지역변수를 만들지 못하면 이전 호출과 구분할수가 없어서 순환 호출이 불가능하다
### 순환 알고리즘의 구조
- 자기 자신을 순환적으로 호출하는 부분
- 순환 호출을 멈추는 부분
- 만약 순환 호출을 멈추는 부분이 없가면 시스템 스택을 다 사용할 때까지 순환적으로 호출되다가 오류 발생
### 순환 <-> 반복
1. 반복
	1. for / while 등의 반복구조로 되풀이
	2. 간명하고 효율적으로 되풀이를 구현하는 방법
2. 순환
	1. 주어진 문제를 해결하기 위하여 자신을 다시 호출하여 작업을 수행하는 방식
> 기본적으로 반복과 순환은 문제 해결 능력이 같으며
> 많은 경우에 서로 바꾸어 써도 잘 작동한다
> 순환 호출이 끝에서 이뤄지는 순환을 꼬리 순환이라고 하는데, 이를 반복으로 쉽게 바꾸어 쓸 수 있다
### 순환의 원리
> 문제의 일부를 해결한 다음, 나머지 문제에 대하여 순환 호출

```C
factorial(int n) {
	if(n <= 1) {
		return 1;
	} else {
		return (n * factorial(n-1));
		// n -> 해결된 부분
		// factorial(n-1) -> 남아있는 부분
	}
}
```
- 주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 방법을 분할정복이라고 함
- 순환호출이 일어날 때마다 문제의 크기가 작아짐
- 팩토리얼, ㅣㅍ보나치, 이항계수, 이진트리, 이진탐색, 하노이의 탑에 유용
### 순환 알고리즘의 성능
팩토리얼 함수에서
- 반복 : for를 사용하여 n번 반복하므로 시간복잡도는 O(n)
- 순환 : 한번 호출할 때마다 1번의 곱셈이 수행되고 n번 호출되므로 O(n)
> 순환 알고리즘은 이해하기 쉽다는 것과 쉽게 프로그래밍 할 수 있는 대신 수행 시간과 기억 공간의 사용에 있어서는 비효율적인 경우 많다
> 순환 호출시에는 호출이 일어날 때마다 호출하는 함수의 상태를 기억해야 하므로 여분의 기억장소가 필요하다
## 2.2 거듭제곱값 계산
> n이 짝수인 경우에는 x^2를 먼저 계산하고 이 값을 n/2제곱하는 것이다
> n이 홀수인 경우에는 x^2을 (n-1)/2제곱하고 여기에 x를 곱해주면 된다
```C
double power(double x, int n) {
	if(n == 0) {
		return 1;
	} else if((n % 2) == 0) {
		return power(x * x, n / 2);
	} else {
		return x * power(x * x, (n - 1) / 2);
	}
}
```
- 문제의 크기가 줄어듦을 유의
- 알고리즘은 더 복잡해보이고 함수호출도 하지만 순환적이 더 빠름
- 한번의 순환 호출을 할 때마다 문제의 크기가 절반씩 줄어듦
- 시간 복잡도는 O(log2n)
## 2.3 피보나치 수열의 계산
똑같은 계산을 몇번씩 반복한다면 아주 단순한 경우라 할지라도 계산시간이 엄청나게 길어질 수 있다
- 피보나치 수열에서는 앞의 두 개의 숫자를 더해서 뒤의 숫자를 만든다
- 피보나치 수열은 정의 자체가 순환적으로 되어 있다.
- 따라서 구현 시 순환 호출을 사용하는 것이 자연스러운 방법인다
```C
// 순환적인 피보나치 수열 계산 프로그램
int fib(int n) {
	if(n == 0) return 0;
	if(n == 1) return 1;
	return (fib(n-1) + fib(n-2));
}
```
> 매우 단순하고 이해하기 쉽지만 매우 비효율적
> fib(6)으로 호출하였을 경우 fib(4) 두번, fib(3) 세번이나 계산되기 때문
> 순환호출이 깊어질수록 점점 심해진다
> 비효율적임

![](https://blog.kakaocdn.net/dn/uD2yY/btra4XZMw5u/vMemLr9QZgv3POuYO2OpT1/img.png)

-> n이 커지면 순환호출을 사용하여 피보나치 수열을 계산하는 것은 거의 불가능
-> 시간복잡도도 크다

- 순환을 사용하지 않고 반복구조를 이용하여 프로그래밍하면 좋은 결과를 얻을 수 있다
```C
int fib_iter(int n) {
	if(n == 0) return 0;
	if(n == 1) return 1;
	
	int pp = 0;
	int p = 1;
	int result = 0;

	for(int i = 2; i <= n; i++) {
		result = p + pp;
		pp = p;
		p = result;
	}
	return result;
}
```
## 2.4 하노이탑 문제
### 조건
- 한번에 하나의 원판만 이동할 수 있다
- 맨 위에 있는 원판만 이동할 수 있다
- 크기가 작은 원판위에 큰 원판이 쌓일 수 없다
- 중간의 막대를 임시적으로 이용할 수 있으나 앞의 조건을 지켜야 한다
### 해결
- 순환적으로 해결
- 순환이 일어날수록 문제의 크기가 작아져야 함
- 문제의 크기는 이동하여야 하는 디스크의 개수
### 소스코드
```C
#include <stdio.h>

void hanoi_tower(int n, char from, char tmp, char to) {
	if(n == 1) {
		printf("원판 1을 %c에서 %c로 옮긴다.\n", from, to);
	} else {
		hanoi_tower(n - 1, from, to, tmp);
		printf("원판 %d을 %c에서 %c로 옮긴다.\n", n, from, to);
		hanoi_tower(n - 1, tmp, from, to);
	}
}

int main(void) {
	hanoi_tower(4, 'A', 'B', 'C');
	return 0;
}
```
### 반복적인 형태로 바꾸기 어려운 순환
```C
// 1
return n * factorial(n - 1);

// 2
return factorial(n - 1) * n;
```
1. 꼬리 순환의 경우 쉽게 반복적인 형태로 변환 가능
2. 머리 순환의 경우 혹은 여러 군데에서 자기 자신을 호출하는 경우는 쉽게 변환 불가
-> 동일한 알고리즘을 꼬리 순환과 머리 순환 양쪽으로 표현할 수 있다면 당연히 꼬리 순환으로 작성