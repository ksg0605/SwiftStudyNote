> 정렬 알고리즘을 평가하는 효율성의 기준은 정렬을 위해 필요한 비교 연산의 횟수와 이동 연산의 횟수이다
> 이 횟수는 자료의 초기화 여부에 의존적이다
> 단순한 정렬 알고리즘은 구현이 쉬운 대신 비요윻
> 복잡한 정렬 알고리즘은 구현이 어려운 대신 효율적
> 내부정렬은 정렬 전 모든 데이터가 메모리에 올라와 있는 것
> 외부정렬은 정렬 전 데이터가 다른 곳에 있고 일부만 메모리에 올라와 있는 것
> 안정성 -> 값이 같은 데이터가 정렬 후에도 같은 위치인 것을 보장할 수 있는가

## 12.2 선택 정렬
- 왼쪽 리스트에는 정렬 완료된 숫자가 들어가고 오른쪽은 막 들어가 있음
- 오른쪽에서 가장 작은 숫자를 왼쪽으로 옮김
- 하나의 배열로만으로도 가능
- 최솟값을 찾아 맨 앞 숫자와 교환
- 이를 반복
```C
void selection_sort(int list[], int n) {
	int i, j, least, temp;
	for(i=0; i<n; i++) {
		least = i;
		for(j=i+1; j<n; j++) {
			if(list[j] < list[least]) least = j;
		}
		swap(list[i], list[least], temp);
	}
}
```
- 시간복잡도는 O(n^2)
  ## 12.3 삽입 정렬
1. 인덱스 1부터 시작한다. 인덱스 0은 이미 정렬된 것으로 볼 수 있다
2. 현재 삽입될 숫자인 i번째 변수를 key 변수로 복사
3. 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다
4. j값이 음수가 아니어야 되고 key값보다 정렬된 배열에 있는 값이 크면
5. j를 하나 감소한다
6. j번째 정수가 key보다 작으므로 j+1번째가 key값이 들어갈 위치이다.
```C
void insertion_sort(int list[], int n) {
	int i, j, key;
	for(i=0; i<n, i++) {
		key = list[i];
		for(j=i-1;j>=0 && list[j]>key; j--) {
			list[j+1] = list[j];
		}
		list[j+1] = key;
	}
}
```
### 삽입 정렬의 복잡도 분석
입력 자료가 역순일 경우가 최악의 경우 n*(n-1)/2 = O(n^2)
## 12.4 버블 정렬
> 인접한 두 개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환하는 비교-교환 과정을 리스트의 왼쪽 끝에서 시작하여 오른쪽 끝까지 진행
> 한 사이클이 돌면 가장 큰 값이 가장 오른쪽으로 감

```C
#define SWAP(x, y, t) ((t)=(x), (x)=(y), (y)=(t))

void bubble_sort(int list[], int n) {
	int i, j, temp;
	for(i=n-1; i>0; i--) {
		for(j=0; j<i; j++) {
			if(list[j] > list[j+1])
				SWAP(list[j], list[j+1], temp);
		}
	}
}
```
### 버블 정렬의 복잡도 분석
- O(n^2)
- 일반적으로 자료의 교환 작업이 자료의 이동 작업보다 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 잘 쓰이지 않는다
## 12.5 쉘 정렬
> 삽입 정렬은 요소들이 삽입될 때 이웃한 위치로만 이동
> 멀리 떨어진 곳은 이동을 많이 해야 이동 가능
> 쉘 정렬은 리스트를 일정한 기준에 따라 분류하여 연속적이지 않으녀 여러 부분 리스트를 만들고
> 각 부분 리스트를 삽입 정렬을 이용하여 정렬
> 부분 리스트가 정렬되면 쉘정렬은 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 다음에 알고리즘 되풀이
> 주어진 리스트의 각 간격 k를 추출하여 만듦, 각 스텝마다 간격을 줄인다
> 마지막에서는 간격이 1이 됨
> 간격은 처음에는 n/2가 되고 각 패스마다 간격이 절반으로 줄어들음
> 만약 짝수면 간격에 1을 더함

```C
void insertion_sort(int list[], int first, int last, int gap) {
	int i, j, key;
	for(i=first+gap; i<last; i = i+gap) {
		key = list[i];
		for(j=i-gap; j>=first && key<list[j]; j=j+gap) {
			list[j+gap] = list[j];
		}
		list[j+gap] = key;
	}
}

void shell_sort(int list[], int n) {
	int i, gap;
	for(gap=n/2; gap;0; gap/2) {
		if((gap % 2) == 0) gap++;
		for(i=0; i<gap; i++) {
			insertion_sort(list, i, n-1, gap);
		}
	}
}
```
### 쉘 정렬의 분석
- 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동한다
- 삽입 정렬에서는 한 번에 한 칸씩만 이동
- 교환되는 아이템들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높아진다
- 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개소가 1ㅇ이 되면
- 셀 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 빠르게 수행한다
- O(n^2)이 최악의 경우지만 평균적으로 O(n^1.5) 정도로 나타난다
