- DBMS의 가장 중요한 특징 중 하나나는 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터의 일관성을 유지하는 것
- DBMS의 동시제어 모듈이 기능 담당
- DBMS 동시성 제어 모듈은 동시에 수행되는 트랜잭션들 간의 간섭을 제어하여 데이터베이스의 일관성을 보장
- 여러 사용자들이 임의의 갱신 연산들을 수행하는 도중에 컴퓨터 시스템이 다운되더라도 데이터베이스의 일관성을 유지해야 함
- DBMS의 회복 모듈이 담당
- 데이터베이스를 갱신하는 도중에 시스템이 고장나도 데이터베이스의 일관성이 유지되도록 함
- 동시성 제어 모듈과 회복 모듈을 합쳐서 트랜잭션 관리모듈이라고 한다
## 데이터베이스 연산
일반적으로 디스크와 메인 메모리 간의 데이터 이동은 블록 단위로 수행
- input(x) : 데이터베이스 항목 X를 포함하고 있는 블록을 주기억장치의 버퍼로 읽어들임
- output(x) : 데이터베이스 항목 X를 포함하고 있는 블록을 디스크에 기록함
- read(x) : 주기억장치 버퍼에서 데이터베이스 항목 X의 값을 프로그램 변수 X로 복사함
- write(x) : 프로그램 변수 x의 값을 주기억 장치 내의 데이터베이스 항목 x에 기록함
![[스크린샷 2024-01-15 오후 2.58.36.png]]
## 트랜잭션
- 데이터베이스 응용에서 하나의 논리적인 단위를 수행하는 데이터베이스 연산들의 모임
- 하나의 논리적 기능을 수행하기 위한 작업의 단위
![[스크린샷 2024-01-15 오후 5.30.40.png]]
## 트랜잭션의 특성(ACID)
- 원자성
	- 할거면 다 하고 아님 말고
	- 즉 한 트랜잭션의 모든 연산이 데이터베이스에 완전히 반영되거나 전혀 반영되지 않아야 함
	- 원자성은 DBMS의 회복 모듈이 유지한다
- 일관성
	- 한 트랜잭션을 정확하게 수행하고 나면 데이터베이스가 하나의 일관된 상태에서 다른 일관된 상태로 바뀐다
	- 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태를 갖지 않을수도 있다
	- 일관성은 트랜잭션을 작성하는 사용자와 무결성 제약조건을 유지하는 DBMS의 일부 모듈이 유지
	- 동시에 다수 사용자가 데이터베이스를 접근하여 검색 및 개인 연산을 수행하는 환경에서 무결성 제약조건 검사만으로는 데이터베이스 일관성 보장 불가
	- DBMS의 동시성 제어 모듈이 다수의 사용자의 서로 상충되는 데이터베이스 접근을 조정
![[스크린샷 2024-01-15 오후 5.35.36.png]]
- 고립성
	- 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야한다
	- 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 한다
	- DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장한다
	- DBMS는 응용들의 요구사항에 따라 다양한 고립 수준을 제공한다
- 지속성
	- 한 트랜잭션이 완료되면 갱신 후 고장나더라도 손실되지 않음
	- 완료된 트랜잭션의 효과는 시스템이 고장난 이우헤도 데이터베이스에 반영
	- DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성 보장
![[스크린샷 2024-01-15 오후 5.38.26.png]]
## 트랜잭션의 연산
#### 완료 (COMMIT)
- 트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영
- 트랜잭션이 종료 후, 데이터베이스가 일관된 상태를 유지할 때 갱신 연산이 완료되었다고 관리자에게 알려주고 결과를 최종적으로 데이터베이스에 반영하는 연산
- SQL 구문 : `COMMIT WORK`
#### 철회 (ROLLBACK)
- 트랜잭션에서 변경하려는 내용이 데이터베이스에 일부만 반영된 경우에는 원자성을 보장하기 위해서, 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌림
- 롤백 연산은 하나의 트랜잭션이 비정상적으로 종료되어 데이터베이스의 일관성을 잃었을 때 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션 수행 이전의 상태로 돌아가는 연산
- 롤백을 하는 경우엔 해당 트랜잭션을 재시작하거나 폐기
- SQL 구문 : `COMMIT WORK`
### 트랜잭션 상태
1. 활동(active) : 트랜잭션이 실행 시작하였거나 실행중인 상태
2. 부분완료(partially commited) : 트랜잭션이 마지막 명령문을 실행한 직후의 상태, 최종 결과를 데이터베이스에 아직 반영하지 않은 상태
3. 완료(committed) : 트랜잭션이 실행을 성공적으로 완료하여 commit연산을 수행한 상태
4. 실패(failed) : 정상적 실행을 더이상 계속할 수 없어서 중단한 상태
5. 철회(aborted) : 트랜잭션이 실행을 실패하여 롤백 연산을 수행한 상태
	- 장애 원인이 HW / SW 오류일 시 재시작, 트랜잭션 내부 오류일 시 폐기
![[스크린샷 2024-01-15 오후 5.45.03.png]]
# 동시성 제어
>동시에 수행되는 다수의 트랜잭션이 존재할 때 고립성을 유지
## 동시성 제어 없이 여러 트랜잭션을 동시에 수행하면 생기는 문제점
- 갱신 손실 : 수행중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효됨
![[스크린샷 2024-01-15 오후 5.46.32.png]]
- 모순성(오손 데이터 읽기) : 아직 종료(commit)되지 않은 트랜잭션의 쓰기 내용을 읽는 것으로 비정상적 상태의 데이터를 읽게 되는 현상
![[스크린샷 2024-01-15 오후 5.48.16.png]]
- 반복할 수 없는 읽기 : 한 트랜잭션이 동일한 데이터를 읽을 때마다 서로 다른 값을 읽는 것
- 연쇄복귀: T1이 롤백되면 잘못된 데이터를 접근한 T2도 같이 롤백해야 한다. 그러니 트랜잭션 T2는 갱신 작업을 성공적으로 완료하고 시스템을 떠난 뒤여서 복귀를 할 수 없는 상황 발생
![[스크린샷 2024-01-15 오후 5.50.13.png]]
# 스케줄
## 트랜잭션 스케줄이란?
> 데이터베이스의 일관적인 상태를 유지하기 위해서 동시에 실행되는 트랜잭션들의 연산 순서를 정하는 것을 의미한다
> 연산 순서에 따라서 결과가 달라지기 떄문에 병행 수행을 하기 위해서는 스케줄이 중요
> 병행수행에서 트랜잭션들은 차례로 번갈아 가면서 수행되는 인터리빙 방식으로 진행된다

![[스크린샷 2024-01-15 오후 5.52.31.png]]

트랜잭션들의 연산을 실행하는 순서인 트랜잭션 스케줄은 세 가지 유형이 존재한다

![![임용1차/전공/DB/#^Table]]
# 로킹
- 동시성 제어를 위해서 가장 널리 사용되는 기법
- 동일한 데이터 항목에 대한 여러 트랜잭션들의 동시 접근을 조정하기 위해 로크가 사용
- 일반적으로 데이터베이스 내의 데이터 항목마다 로크가 존재
- 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할때마다 요청한 로크의 정보는 로크 테이블에 유지
- 트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에는 로크 해제
## 로킹 규약
1. 트랜잭션은 데이터에 접근하기 위해 먼저 락 연산을 실행 -> 독점권 획득 (리드 혹은 라이트 실행 전 락 실행)
2. 다른 트랜잭션에 의해 이미 락이 걸려있는 데이터에는 다시 락을 실행할 수 없다
3. 독점권을 획득한 데이터에 대한 모든 연산의 수행이 끝나면 트랜잭션은 언락연산을 실행하여 독점권을 반납
## 로크 연산 종류
- 공유 로크: 트랜잭션에서 읽을 목적으로 데이터 항목을 접근할 때 요청 (리드 가능, 라이트 불가능, 여러 트랜잭션이 실행 가능)
- 독점 로크: 트랜잭션에서 갱신을 목적으로 데이터 항목을 접근할 때 요청 (리드/라이트 둘다 불가능, 한 트랜잭션만 사용 가능)

![[스크린샷 2024-01-15 오후 9.10.54.png]]
## 2단계 로킹 규약(2PLP)
- 로크를 요청하는 것과 로크를 해제하는 것이 2단계로 이뤄진다
- 로크 확장 단계가 지난 후에 로크 수축단계로 들어간다
- 일단 로크를 한개라도 해제하면 로크 수축 단계에 들어간다
- 어떤 한 스케줄이 참여하고 있는 모든 트랜잭션들이 2단계 로킹 규약을 준수한다면 그 스케줄을 직렬 가능하다
![[스크린샷 2024-01-15 오후 9.13.12.png]]
## 2단계 로킹 규약의 유형
- 엄밀 2단게 로킹 규약: 독점 로크는 그 트랜잭션이 완료할 때까지 언락하지 않고 그대로 유지
- 엄격 2단계 로킹 규약: 엄밀 2PLP보다 더 제한적, 모든 로크는 트랜잭션이 완료할 때까지 언락 금지
# 회복
- 트랜잭션이 버퍼에는 갱신 사항을 반영했지만 버퍼의 내용을 디스크의 데이터베이스에 기록되기 전에 고장이 날 수 있다
- 이런 경우 회복 모듈은 고장이 발생한 시점에 갱신을 수행한 트랜잭션들의 상태를 조사해야 한다
- 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행했다면 회복 모듈은 이 트랜잭션의 갱신 사항을 리두하여 트랜잭션의 갱신이 지속성을 갖게 해야한다
- 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행하지 못한다면 원자성을 보장하기 위해 이 트랜잭션이 데이터베이스에 반영했을 가능성이 있는 갱신 사항을 언두해야한다
![[스크린샷 2024-01-15 오후 9.34.27.png]]
## 로그를 이용한 회복
### 로그 레코드
- `<Ti, Start>` : 트랜잭션 시작
- `<Ti, Xj, V1, V2>` : X값을 V1 -> V2로 변경
- `<Ti, Commit>` : 트랜잭션 완료
- `<Ti, Rollback>` : 트랜잭션 철회
### 지연 갱신
- 부분 완료될 때까지 모든 output연산을 지연하고 변경은 로그에 기록
- 로그 레코드 형식 `<Ti, 데이터아이템, 변경된 값>`
- 트랜잭션 수행 도중 데이터베이스에는 영향이 없으므로 undo는 필요X
- commit이 로그에 정상적으로 찍혀있더라도 디스크에 저장되지 않을 경우를 대비 redo만
- 장애 발생 시 `<Ti, Start>, <Ti, Commit>` 로그 레코드가 모두 있는 트랜잭션에 대해 Redu
![[스크린샷 2024-01-15 오후 9.43.30.png]]
![[스크린샷 2024-01-15 오후 9.43.43.png]]
### 즉시 갱신
- 데이터의 변경 결과를 데이터베이스에 그대로 반영
- 로그 레코드 형식 : `<트랜잭션 id, 데이터아이템, 변경전 값, 변경된 값>`
- 장애 발생 시 `<Ti, Start>, <Ti, Commit>`있으면 redu `<Ti, Start>`만 있으면 undo
> 데이터를 돌릴 때 undo는 역순으로 redu는 정순으로 복구
> undo부터 복구한다

![[스크린샷 2024-01-15 오후 9.46.04.png]]
### 로그 레코드 버퍼링
> 로그 레코드가 만들어지는 즉시 안정 저장소에 출력시키는 것은 비용이 많이 든다
> 로그 레코드를 메인 메모리의 버퍼 블록에 모아 한꺼번에 출력
> 시스템 붕괴 시 로그 레코드가 손실된 위험성이 존재

### 로그 우선 기록 규약 (WAL)
> 데이터베이스 버퍼보다 로그 버퍼를 먼저 디스크에 기록해야 한다

1. 트랜잭션 `<Ti, Commit>`로그 레코드를 안정 저장장치에 출력시켜야만 완료 상태로 드감
2. commit 로그 레코드를 출력하기 위해 먼저 트랜잭션과 관련된 모든 로그를 안정 저장장치에 출력
3. DB버퍼 블록 출력 전에 버퍼 블록 데이터와 관련된 모든 로그 레코드가 안정 저장장치에 출력
### 데이터베이스 버퍼링
- 버퍼에 자리 부족 -> 기존블록 하나 없앰 -> 아직 그 블록이 커밋 X -> 버퍼의 로그 정보를ㄹ 먼저 디스크에 저장 -> 블록 쫒아냄
## 검사시점 회복
- 로그 사용기법에서는 리두와 언두해야할 트랜잭션을 결정하기 위해 모든 로그를 조사해야 함
- 회복시 재수행할 트랜잭션의 수를 줄이기 위해 주기적으로 체크포인트 실행
### 검사 시점 (체크포인트 시점)
1. 메인메모리에 있는 모든 로그 레코드를 안정 저장소로 기록
2. 주기억장치의 버퍼내용 전부를 디스크에 강제 기록
3. 작업이 끝나면 로그에 `<checkpoint L>` 로그 레코드를 기록 (L은 현재 실행중인 트랜잭션의 리스트)
### 트랜잭션 목록 결정 방법
1. 체크포인트 이전의 트랜잭션들은 회복 작업이 필요X
2. 검사시점 당시 실행중인 트랜잭션은 undo 리스트에 삽입
3. 로그를 차례로 읽으며 `<Ti, Start>`레코드 만날 시 undo 리스트에 삽입
4. 체크포인트 이전 이후 관계없이 장애 발생 시간에 진행중인 트랜잭션은 undo
5. 로그를 차례로 읽으며 `<Ti, Commit>`레코드 만나면 redo 리스트로 옮김
6. 체크포인트 상관없이 장애 발생 이전에 종료된 트랜잭션은 redo
### 회복
1. 후진 회복 : undo 연산 수행 (로그에 기록된 역순으로)
2. 전진 회복 : redo 연산 수행 (로그에 기록된 순서대로)
![[스크린샷 2024-01-15 오후 10.09.00.png]]
- T2 : C이후 일어난 부분만 redo
- T3 : undo
- T4 : redo
- T5 : undo
